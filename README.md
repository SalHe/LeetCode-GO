# LeetCode-GO

个人的LeetCode算法练习代码

## 心得体会

### 利用分治策略降低时间复杂度

对于某一个较大规模的问题，通过将其划分为多个小规模的问题（但是与之前的解法不变）。其每个小规模的问题的时间复杂度累积起来之后，原复杂度中的某个$n$项会变为$lg n$项。比如某算法复杂度为$O(n^2)$，分治后变为$O(n lg n)$。

一个很鲜明的例子是：[合并K个已排序链表](/leetcode/0023.Merge-K-Sorted-Lists/0023.Merge-K-Sorted-Lists.go)。

在[最初的版本](https://github.com/SalHe/LeetCode-GO/blob/c7d037aa6dc9b31c5fee2f39c4efe40a695606fe/leetcode/0023.Merge-K-Sorted-Lists/0023.Merge-K-Sorted-Lists.go)中，是普通的版本。而在[改进版本](https://github.com/SalHe/LeetCode-GO/blob/0e9fee9d4c0de7d5d077d7fbc040e180ae325b7b/leetcode/0023.Merge-K-Sorted-Lists/0023.Merge-K-Sorted-Lists.go)中，仅仅只是把算法改进成了运用分治策略的算法，速度就显著提升了N倍（力扣测试时间由312ms改进到了12ms）。

### 特定情况下合理设计标记以使用现有空间

当期望的空间复杂度为$O(1)$，而输入为变长数组时，倘若我们需要做一些标记信息，一般情况下是需要**额外**的复杂度为$O(n)$的空间的。但是如果输入数组是允许被修改的话，那么我们可以根据要求去判断是否能够设计一个既能表达标记信息、又能在遍历之时能够部分还原原信息以求解的标记方式，将标记信息结合设计进行存放。这使得我们在使用额外的$O(1)$空间的情况下，仍能使用标记信息。

例子：[缺失的第一个正数](/leetcode/0041.First-Missing-Positive/0041.First-Missing-Positive.go)

在这个例子中，我们希望记录1~N之间的正整数的是否已出现（N为数组长度），但又希望保证空间复杂度为$O(1)$。由于输入并没有要求说不允许改变，所以我们考虑在输入数组中存放`出现标记`。

那么要如何设计这样的标记，既能表现`出现`，又能在我们需要时，还原原本的数字呢？

在此算法中，显然，输入中的非正整数并不会影响算法的结果，故而可以考虑借助整数的**正负性**来表现`出现`。由于正整数本身对算法产生影响，故而我们选择使用**负**来表现`出现`。既然使用了**负**来表现`出现`，那么原本输入中的负数必然对我们的判断会产生影响，所以我们还得考虑将输入中原本就存在的非正整数变换成不影响算法输出的正整数。

在此例中，我们将非正整数替换成N+1。

在准备完之后，我们要怎么对那些原本就出现的且对输出有影响的正整数进行遍历呢？由于我们将非负整数替换成了对输出没有影响的正整数，所以我们只需要对那种对输出有影响的正整数进行遍历，其他的跳过即可。

我们每遇到一个有效元素，就对其对应的位置(不一定是其在元素中对应的位置)用负值标记——而这里的标记也很讲究，我们使用了对应位置处的元素的绝对值的负值作为用于标记的负值。这是为什么呢？因为我们的使用负值填充某一位置，必定导致其值的丢失。所以我们使用其绝对值负值作为标记(因为我们准备工作中已经去除了负值，故一旦遇到负值就可以肯定是由于我们的预防行为产生的)。

为什么是绝对值的负值，而不是对应位置值的负值(我们之前已经将输入数组转换为全正的数组了)呢？因为某一元素可能出现多次，如此一来，被替换的值将正负反复横跳，将会影响我们最后对`出现性`的判断。